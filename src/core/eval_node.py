"""
This module defines the evaluation nodes for the shell engine.

The eval nodes are responsible for interpreting the abstract syntax tree (AST)
generated by the parser. Each node type corresponds to a specific shell command
construct, such as sequences of commands, pipes, command calls, arguments,
redirections, and various types of quoted strings or variable expansions.

These nodes do not perform the actual execution of external programs directly.
Instead, they prepare the necessary execution context (e.g., input/output
streams, environment variables) and then delegate the execution to the
runtime components.

Each `EvalNode` subclass:
- Is registered with a specific type name (e.g., "seq", "pipe", "call").
- Implements an `eval` method that takes a context object and processes its
  part of the AST.
- Specifies the form of its return value in its docstring, allowing parent
  nodes to correctly interpret the results of child node evaluations.
- Raises ValueError for invalid command structures.
"""

from core.eval_tree import EvalNode, register, create_eval_node
from core.utils import IOFileManager, char_with_info_list
from core.runtime import execute_app
from core.shell_parser.parser import parse_command
from glob import glob
from io import StringIO


@register("seq")
class SeqNode(EvalNode):
    """
    Represents a sequence of eval nodes.
    Return value: None
    """
    def __init__(self, ast: dict):
        self.commands = ast.get("commands", [])

    def eval(self, context=None):
        """
        Evaluate the sequence of commands.
        """
        for command in self.commands:
            command_node = create_eval_node(command["type"], command)
            command_node.eval(context)


@register("pipe")
class PipeNode(EvalNode):
    """
    Represents a pipe of eval nodes.
    Return value: None
    """
    class PipeSegment:
        """
        Represents a segment in a command pipe, responsible for executing
        one command and then recursively triggering the next segment.

        An instance of PipeSegment handles the first command in the provided
        commands list. It sets up the input and output streams for this
        command. If it's the last command in the pipe, output goes to the
        pipe's final destination. Otherwise, output goes to a temporary
        in-memory stream, which then becomes the input for a new PipeSegment
        instance created for the remaining commands.
        """
        def __init__(self, commands, context):
            self.commands = commands
            self.ori_pipe_context = context

        def execute(self, input_stream):
            my_seg_context = self.ori_pipe_context.copy()
            my_seg_context.set("input_stream", input_stream)
            # the last command in the pipe
            if len(self.commands) == 1:
                my_seg_context.set("output_stream",
                                   self.ori_pipe_context.get("output_stream"))
            else:
                pipe_out = StringIO()
                my_seg_context.set("output_stream", pipe_out)
            command_node = create_eval_node(self.commands[0]["type"],
                                            self.commands[0])
            command_node.eval(my_seg_context)
            # the last command in the pipe
            if len(self.commands) == 1:
                return
            else:
                pipe_in = StringIO(pipe_out.getvalue())
                pipe_out.close()
                next_seg = PipeNode.PipeSegment(self.commands[1:],
                                                self.ori_pipe_context)
                next_seg.execute(pipe_in)
                pipe_in.close()
                return

    def __init__(self, ast: dict):
        self.commands = ast.get("commands", [])

    def eval(self, context=None):
        """
        Evaluate the pipe of commands.
        Set up the first command, then recursively trigger the next segment.
        """
        pipe_segment = PipeNode.PipeSegment(self.commands, context)
        pipe_segment.execute(context.get("input_stream"))


@register("call")
class CallNode(EvalNode):
    """
    Execute a command with arguments and redirections.
    Responsible for handling the command name and its arguments.
    It also manages input and output redirections.
    Return value: None
    """
    def __init__(self, ast: dict):
        self.args = ast.get("arguments_or_redirect", [])

    def eval(self, context=None):
        """
        Evaluate the call command.
        """
        is_redirect_in = False
        is_redirect_out = False
        redirect_infile, redirect_outfile = None, None
        redirect_outfile_mode = "w"
        argments = []
        for arg in self.args:
            argment_node = create_eval_node(arg["type"], arg)
            argment = argment_node.eval(context)
            if arg["type"] == "redirection" and argment[0] == "<":
                if is_redirect_in:
                    raise ValueError("multiple redirect in")
                is_redirect_in = True
                redirect_infile = argment[1]
                # the first two elements are the redirection symbol
                # and the file name, the rest are the
                # arguments for the command.
                if len(argment) > 2:
                    argments.extend(argment[2:])
            elif arg["type"] == "redirection" and argment[0][0] == ">":
                if is_redirect_out:
                    raise ValueError("multiple redirect out")
                is_redirect_out = True
                # if the redirection symbol is ">>",
                # we will append to the file,
                # otherwise we will overwrite the file.
                redirect_outfile_mode = "a" if len(argment[0]) > 1 else "w"
                redirect_outfile = argment[1]
                if len(argment) > 2:
                    argments.extend(argment[2:])
            else:
                argments.extend(argment)
        call_context = context.copy()
        with IOFileManager(redirect_infile, redirect_outfile,
                           redirect_outfile_mode) as io_file_manager:
            input_stream, output_stream = io_file_manager
            if input_stream is not None:
                call_context.set("input_stream", input_stream)
            if output_stream is not None:
                call_context.set("output_stream", output_stream)
            if len(argments) == 0:
                raise ValueError("no command to execute")
            command = argments[0]
            execute_app(command, argments[1:], call_context)


@register("argument")
class ArgumentNode(EvalNode):
    """
    Represents an argument in a command.
    Responsible for handling the argument value for
    globbing and command substitution splitting.
    Return value: list of strings, which is the final argument list
    to be passed to the command.
    """
    def __init__(self, ast: dict):
        self.values = ast.get("values", [])

    def eval(self, context) -> list[str]:
        """
        Evaluate the argument node.
        Arguments are split into a list of strings.
        Using the char_with_info_list to wrap the content
        and glob module for globbing.
        """
        args = []
        for value in self.values:
            arg = create_eval_node(value["type"], value).eval(context)
            if (value["type"] == "backquoted"):
                # we can't use parse_command here,
                # as the command substitution may contain backquote,
                # and we don't support recursive command substitution.
                # so we need to split it manually.
                self.__command_substitution_split(arg, args)
            elif (value["type"] == "single_quoted"
                  or value["type"] == "double_quoted"):
                self.__non_or_quoted_split(arg, args, True)
            else:
                self.__non_or_quoted_split(arg, args, False)
        result = []
        for i in range(len(args)):
            arg = args[i]
            if str(arg) == "":
                continue
            glob_mask = arg.get_glob_mask()
            globbed = glob(glob_mask)
            if len(globbed) > 0:
                result.extend(globbed)
            else:
                result.append(str(arg))
        return result

    def __command_substitution_split(self, arg: str,
                                     args: list[char_with_info_list]):
        """
        Split the command substitution content.
        Also wrap the content with char_with_info_list for globbing.
        """
        tmp_args = []
        if arg.startswith(" "):
            # if the first char is space, split from previous
            tmp_args.append("")
        tmp_args.extend(arg.split())
        if arg.endswith(" "):
            # if the last char is space, split from next
            tmp_args.append("")
        for i in range(len(tmp_args)):
            # command substitution content treated as nonquoted
            tmp_args[i] = char_with_info_list(tmp_args[i], False)
        if len(args) > 0:
            args[-1] += tmp_args[0]
            if len(tmp_args) > 1:
                args.extend(tmp_args[1:])
        else:
            args.extend(tmp_args)

    def __non_or_quoted_split(self, arg: str,
                              args: list[char_with_info_list],
                              is_quoted: bool):
        """
        Extend the arg to the args list.
        Also wrap the content with char_with_info_list for globbing.
        """
        arg = char_with_info_list(arg, is_quoted)
        if len(args) > 0:
            args[-1] += arg
        else:
            args.append(arg)


@register("redirection")
class RedirectionNode(EvalNode):
    """
    Represents a redirection in a command.
    Return value: list of strings, which is the redirection symbol
    and the file names(maybe more than one).
    """
    def __init__(self, ast: dict):
        self.redirect_symbol = ast.get("redirect_symbol", "")
        self.file_argument = ast.get("file_argument", {})

    def eval(self, context) -> list[str]:
        file_names_node = create_eval_node(self.file_argument["type"],
                                           self.file_argument)
        file_names = file_names_node.eval(context)
        if len(file_names) == 0:
            raise ValueError("no file to redirect")
        return [self.redirect_symbol] + file_names


@register("non_keyword")
class NonKeywordNode(EvalNode):
    """
    Represents a non-keyword argument in a command.
    Return value: string, which is the argument value.
    """
    def __init__(self, ast: dict):
        self.value = ast.get("value", "")

    def eval(self, context) -> str:
        return self.value


@register("single_quoted")
class SingleQuotedNode(EvalNode):
    """
    Represents a single quoted argument in a command.
    Return value: string, which is the argument value.
    """
    def __init__(self, ast: dict):
        self.value = ast.get("value", "")

    def eval(self, context) -> str:
        return self.value


@register("double_quoted")
class DoubleQuotedNode(EvalNode):
    """
    Represents a double quoted argument in a command.
    Return value: string, which is the double quoted content
    and the command substitution content.
    """
    def __init__(self, ast: dict):
        self.values = ast.get("values", [])

    def eval(self, context) -> str:
        contents = []
        for value in self.values:
            content_node = create_eval_node(value["type"], value)
            content = content_node.eval(context)
            contents.append(content)
        return "".join(contents)


@register("backquoted")
class BackQuotedNode(EvalNode):
    """
    Represents a back quoted argument in a command.
    Responsible for command substitution.
    Return value: string, which is the command substitution value.
    """
    def __init__(self, ast: dict):
        self.content = ast.get("value", {})

    def eval(self, context) -> str:
        command_content_node = create_eval_node(self.content["type"],
                                                self.content)
        command_content = command_content_node.eval(context)
        pipe_out = StringIO()
        # use the root context as the command substitution
        # is evaluated separately.
        pipe_context = context.get_root_context_copy()
        pipe_context.set("output_stream", pipe_out)
        # there won't be backquote in the command content,
        # so it won't be recursive.
        parse_tree = parse_command(command_content)
        command_node = create_eval_node(parse_tree["type"], parse_tree)
        command_node.eval(pipe_context)
        command_out = pipe_out.getvalue()
        pipe_out.close()
        if command_out.endswith("\n"):
            # remove the last new line character
            command_out = command_out[:-1]
        # remove new line characters
        command_out = command_out.replace("\n", " ")
        return command_out


@register("variable")
class VariableNode(EvalNode):
    """
    Represents a variable in a command.
    Return value: string, which is the variable expansion value.
    """
    def __init__(self, ast: dict):
        self.value = ast.get("value", "")

    def eval(self, context) -> str:
        var_name = self.value
        if var_name == "":
            return ""
        var_value = context.get(var_name)
        if var_value is None:
            return ""
        return var_value
